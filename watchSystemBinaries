#!/bin/bash

# create the status of a file and write it into another file. the status
# contains a filename without, whitespace, permissions, owner, group, size and
# a sha1 checksum
# $1 file to inspect
# $2 file to write the status into
function createStatusAndAppendToFile {
        # $1 is the file to inspect
        fileToInspect=$1
        # $2 is the file in which the status gets written
        fileToWriteTo=$2
        fileStatus=`ls -l "$fileToInspect"`
        set -- junk $fileStatus
        shift
        permissions=$1
        owner=$3
        group=$4
        size=$5
        checkSum=`sha1sum "$fileToInspect" | cut --characters=1-40`
        fileToInspect=`echo "$fileToInspect" | sed 's/ /\\\n/g'`
        echo $fileToInspect $permissions $owner $group $size $checkSum >> $fileToWriteTo
}

function createDirectoryStatus {
        # create a status file of the given directory in $1 and save it to $2
        # get all files of the given directory $ $1 and create its status
        find "$1" -type f -print0 2>/dev/null | while IFS= read -r -d '' filename; do
                createStatusAndAppendToFile "$filename" $2~
        done

        # sort the file
        sort $2~ > $2
        rm $2~
}

# creates a message telling the changes of a file. used to reduce boilerplate
# $1 property of the first file
# $2 property of the second file
# $3 propery name
# $4 file name
# returns a string with the message
function createChangeMessage {
        retval=""
        if [ $1 != $2 ]; then
                retval="file $3 changed on $4: was $1, is $2; "
        fi
        echo $retval
}

# compares two entries and at differences writes them into changes
# 12 arguments, 6 for each entry
# the arguments consist of:
#   filename, permissions, owner, group, size, hash
# returns a status indicating in which array to proceed and a message about
#         changes. the status is:
#          0 proceed the iterator of the old status array (file deleted)
#          1 proceed the iterator of both status arrays (file exist in both)
#          2 proceed the iterator of the new status array (file created)
function compareEntries {
        fn1=$1; perm1=$2; own1=$3; gr1=$4; size1=$5; hash1=$6
        fn2=$7; perm2=$8; own2=$9; gr2=${10}; size2=${11}; hash2=${12}
        local __changes=""
        # compare filenames
        # filenames are equal, test if properties are still the same
        if [ $fn1 = $fn2 ]; then
                local __changes+=`createChangeMessage $perm1 $perm2 permissions $fn1`
                local __changes+=`createChangeMessage $own1 $own2 owner $fn1`
                local __changes+=`createChangeMessage $gr1 $gr2 group $fn1`
                local __changes+=`createChangeMessage $size1 $size2 size $fn1`
                local __changes+=`createChangeMessage $hash1 $hash2 content $fn1`
                retStatus=1
        fi
        if [ $fn1 \< $fn2 ]; then
                local __changes="deleted file $fn1"
                retStatus=0
        fi
        if [ $fn1 \> $fn2 ]; then
                local __changes="added file $fn2"
                retStatus=2
        fi
        echo "$retStatus" "$__changes"
}

# add remaining files, which have been added or deleted
# $1 is the array of the file
# $2 the start position
# $3 if the content is added or removed
function addAddedDeletedFiles {
        declare -a tmpvar=("${!1}")
        for i in $(seq $2 6 $((${#tmpvar[@]} - 1))); do
                changes[${#changes[@]}]="$3 file ${tmpvar[i]}"
        done
}

function readAndCompareStatus {
        status1=( $(cat $1) )
        index1=0
        length1=$((${#status1[@]} - 1))

        status2=( $(cat $2) )
        index2=0
        length2=$((${#status2[@]} - 1))

        changes=()

        while [ $index1 -lt $length1 ] && [ $index2 -lt $length2 ]; do
                # compare two entries of the status arrays
                retval=`compareEntries ${status1[$((index1 + 0))]} ${status1[$((index1 + 1))]} ${status1[$((index1 + 2))]} ${status1[$((index1 + 3))]} ${status1[$((index1 + 4))]} ${status1[$((index1 + 5))]} ${status2[$((index2 + 0))]} ${status2[$((index2 + 1))]} ${status2[$((index2 + 2))]} ${status2[$((index2 + 3))]} ${status2[$((index2 + 4))]} ${status2[$((index2 + 5))]}`
                # only write something if there really is a statusmessage
                if [ ${#retval} -gt 2 ]; then
                        changes[${#changes[@]}]="`echo $retval | cut -c 3-`"
                fi
                # extract the status code and proceed in the property arrays
                statuscode=`echo $retval | cut -c 1-2`
                if [ $statuscode -lt 2 ]; then
                        index1=$(($index1 + 6))
                fi
                if [ $statuscode -gt 0 ]; then
                        index2=$(($index2 + 6))
                fi
        done

        # write rest of the arrays into the changes log
        if [ $index1 -lt $length1 ]; then
                addAddedDeletedFiles status1[@] $index1 "deleted"
        fi
        if [ $index2 -lt $length2 ]; then
                addAddedDeletedFiles status2[@] $index2 "added"
        fi

        # print every change of the filesystem
        for ((i = 0; i < ${#changes[@]}; i++)); do
                echo "${changes[$i]}"
        done
}

# watch the directories /bin, /sbin, /usr/bin and /usr/sbin
# hardcode statusfiles

# compares the old and the new status of a directory and write the results into
# the log
# $1 directory name
# $2 logfile
# $3 directory containing statusfiles
function checkDirectory {
        statusfile="${3}/`echo "$1" | sed 's/\///g'`_status"
        createDirectoryStatus $1 ${statusfile}~
        if [ -f $1 ]; then
                echo "`date` checking $1" >> "$2"
                readAndCompareStatus $statusfile ${statusfile}~ >> "$2"
        fi
        mv ${statusfile}~ $statusfile
}

directories=("/bin" "/sbin" "/usr/bin" "/usr/sbin")
logfile="/var/log/syschecker"
statusdir="."

for dir in ${directories[@]}; do
        checkDirectory $dir $logfile $statusdir
done

exit 0
